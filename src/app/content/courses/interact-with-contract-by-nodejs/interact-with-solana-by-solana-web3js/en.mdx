import { ArticleSection } from "../../../../components/ArticleSection/ArticleSection";

# How to Start Building with the Solana Web3.js SDK

<ArticleSection name="Introduction" id="introduction" level="h2" />

The **Solana Web3.js SDK** is a TypeScript/JavaScript library for building Solana applications on Node.js, web, and React Native. In November 2024, Anza released the **2.0** update with modern JavaScript features: native bigint/crypto types and smaller bundles.

If you use **@solana/web3.js** today, you can either migrate to the new **v2** package or pin to **v1.x**. This article covers what’s new in Web3.js 2.0, how to migrate from v1, and a full example of sending a transaction.

**Assumed knowledge:** Solana basics (transactions, account model, blockhashes, priority fees) and TypeScript or JavaScript. Prior Web3.js v1 experience helps but is not required.

---

<ArticleSection name="What's New in Web3.js 2.0" id="whats-new" level="h2" />

1. **Performance** — Keypair generation, transaction signing, and message verification are much faster (up to ~10x) using native crypto APIs in Node.js and modern browsers.

2. **Smaller bundles** — The library is **tree-shakable** so you only ship what you use, and it has **zero external dependencies**.

3. **Flexibility** — You can:
   - Define RPC instances with custom methods
   - Use custom network transports or transaction signers
   - Compose custom primitives for networking, confirmation, and codecs

TypeScript clients for on-chain programs now live in the **@solana-program** GitHub org and are autogenerated with **Codama**, so you can generate clients for your own programs.

---

<ArticleSection name="Should You Move to Web3.js v2?" id="should-migrate" level="h2" />

As of early 2025:

- **New apps** using standard programs (system, token, associated token, etc.) can use **web3.js v2** now.
- **Anchor-based apps** — Anchor does not yet support web3.js v2 out of the box. You can wait for an Anchor update or use **Codama** to generate a TypeScript client for your program (more setup).

---

<ArticleSection name="Migrating from Web3.js v1" id="migrating-v1" level="h2" />

### Keypairs

- **Keypair** → **KeyPairSigner**. Use **generateKeyPairSigner()** instead of **Keypair.generate()**. Naming is camelCase: **keyPair**.
- Secret keys are **privateKey**, available as **keyPairSigner.privateKey**. Use **KeyPairSigner** wherever v1 used **secretKey**.

### Addresses / Public keys

- **PublicKey** in v1 is replaced by an **address** in v2. **KeyPairSigner** has **keypairSigner.address**. Convert a string to an address with the **address()** function.

### SOL and token amounts

- Amounts use **BigInt**. Use a trailing **n** (e.g. **1n** instead of **1**).

### Factories

- Many features are **factory-based**: you call **doThingFactory()** with options to get a custom **doThing()**.
- **sendAndConfirmTransactionFactory()** — Call once with your RPC/subscription and options to get a **sendAndConfirmTransaction()** you reuse.
- **airdropFactory()** — Call once to get a custom **airdrop()** for devnet/localnet.

---

<ArticleSection name="How to Send Transactions with Web3.js 2.0" id="send-transactions" level="h2" />

We’ll build a small client that **transfers lamports** and follows practices for better success and confirmation speed:

- Fetch the latest **blockhash** with **confirmed** commitment
- Set **priority fees** (e.g. via Helius Priority Fee API)
- Optimize **compute units**
- Send with **maxRetries: 0** and **skipPreflight: true** (only when you’re confident in the transaction)

### Prerequisites

- **Node.js** installed
- An IDE (e.g. VS Code or Cursor)

---

<ArticleSection name="Installation" id="installation" level="h2" />

Create a Node.js project and install dependencies:

```bash
npm init -y
mkdir src
touch src/index.ts
```

```bash
npm install @solana/web3.js@2 @solana-program/system @solana-program/compute-budget esrun
```

- **@solana/web3.js** — Solana Web3.js 2.0 SDK
- **@solana-program/system** — System Program (e.g. lamport transfers)
- **@solana-program/compute-budget** — Priority fees and compute unit instructions
- **esrun** — Run TypeScript from the CLI without extra config

---

<ArticleSection name="Define Transfer Addresses" id="define-addresses" level="h2" />

In your script (e.g. `send-transaction.ts`), define source and destination. Use **address()** for the destination and create a **KeyPairSigner** from the source secret key:

```typescript
import { address, createKeyPairSignerFromBytes, getBase58Encoder } from "@solana/web3.js";

const destinationAddress = address("public-key-to-send-lamports-to");
const secretKey = "add-your-private-key";
const sourceKeypair = await createKeyPairSignerFromBytes(getBase58Encoder().encode(secretKey));
```

---

<ArticleSection name="Configure RPC Connections" id="configure-rpc" level="h2" />

Use **createSolanaRpc** for HTTP and **createSolanaRpcSubscriptions** for WebSocket. Then create a reusable sender with **sendAndConfirmTransactionFactory**:

```typescript
import {
  createSolanaRpcSubscriptions,
  createSolanaRpc,
  sendAndConfirmTransactionFactory,
} from "@solana/web3.js";

const rpc_url = "https://mainnet.helius-rpc.com/?api-key=<your-key>";
const wss_url = "wss://mainnet.helius-rpc.com/?api-key=<your-key>";

const rpc = createSolanaRpc(rpc_url);
const rpcSubscriptions = createSolanaRpcSubscriptions(wss_url);

const sendAndConfirmTransaction = sendAndConfirmTransactionFactory({
  rpc,
  rpcSubscriptions,
});
```

You can get **rpc_url** and **wss_url** from the Helius Dashboard (Endpoints section) or use another RPC provider.

---

<ArticleSection name="Create a Transfer Instruction" id="transfer-instruction" level="h2" />

Fetch the latest blockhash (e.g. **confirmed**) and build a **transfer SOL** instruction with the System Program:

```typescript
import { lamports } from "@solana/web3.js";
import { getTransferSolInstruction } from "@solana-program/system";

const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();

const instruction = getTransferSolInstruction({
  amount: lamports(1n),
  destination: destinationAddress,
  source: sourceKeypair,
});
```

**source** must be a **Signer**; **destination** is an address.

---

<ArticleSection name="Create Transaction Message" id="transaction-message" level="h2" />

Build a **version-aware** transaction message with **pipe**: set fee payer, blockhash lifetime, and the transfer instruction:

```typescript
import {
  pipe,
  createTransactionMessage,
  setTransactionMessageFeePayer,
  setTransactionMessageLifetimeUsingBlockhash,
  appendTransactionMessageInstruction,
} from "@solana/web3.js";

const transactionMessage = pipe(
  createTransactionMessage({ version: 0 }),
  (message) => setTransactionMessageFeePayer(sourceKeypair.address, message),
  (message) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, message),
  (message) => appendTransactionMessageInstruction(instruction, message),
);
```

- **```createTransactionMessage({ version: 0 })```** — Start the message
- **setTransactionMessageFeePayer** — Set fee payer
- **setTransactionMessageLifetimeUsingBlockhash** — Set blockhash lifetime
- **appendTransactionMessageInstruction** — Add the transfer instruction

---

<ArticleSection name="Sign the Transaction" id="sign-transaction" level="h2" />

Sign with the source keypair:

```typescript
import { signTransactionMessageWithSigners } from "@solana/web3.js";

const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);
```

---

<ArticleSection name="Estimate Priority Fees" id="priority-fees" level="h2" />

Use Helius’ Priority Fee API (or another provider) with the serialized transaction in **Base64**:

```typescript
import { getBase64EncodedWireTransaction } from "@solana/web3.js";

const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);

const response = await fetch(rpc_url, {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    jsonrpc: "2.0",
    id: "helius-example",
    method: "getPriorityFeeEstimate",
    params: [
      {
        transaction: base64EncodedWireTransaction,
        options: {
          transactionEncoding: "base64",
          priorityLevel: "High",
        },
      },
    ],
  }),
});
const { result } = await response.json();
const priorityFee = result.priorityFeeEstimate;
```

**priorityLevel: "High"** is often enough; you can use more advanced strategies for congestion.

---

<ArticleSection name="Optimize Compute Units" id="compute-units" level="h2" />

Estimate compute units for the message, add a ~10% buffer, and enforce a minimum (e.g. 1000):

```typescript
import { getComputeUnitEstimateForTransactionMessageFactory } from "@solana/web3.js";

const getComputeUnitEstimateForTransactionMessage = getComputeUnitEstimateForTransactionMessageFactory({ rpc });

let computeUnitsEstimate = await getComputeUnitEstimateForTransactionMessage(transactionMessage);
computeUnitsEstimate = computeUnitsEstimate < 1000 ? 1000 : Math.ceil(computeUnitsEstimate * 1.1);
```

---

<ArticleSection name="Rebuild and Sign the Transaction" id="rebuild-sign" level="h2" />

You can’t add instructions to an already-signed transaction. Rebuild the message with a **new blockhash** and add **set compute unit price** and **set compute unit limit** instructions, then sign again:

```typescript
import { appendTransactionMessageInstructions, setTransactionMessageLifetimeUsingBlockhash } from "@solana/web3.js";
import { getSetComputeUnitLimitInstruction, getSetComputeUnitPriceInstruction } from "@solana-program/compute-budget";

const { value: finalLatestBlockhash } = await rpc.getLatestBlockhash().send();

const finalTransactionMessage = appendTransactionMessageInstructions(
  [
    getSetComputeUnitPriceInstruction({ microLamports: priorityFee }),
    getSetComputeUnitLimitInstruction({ units: computeUnitsEstimate }),
  ],
  transactionMessage,
);

setTransactionMessageLifetimeUsingBlockhash(finalLatestBlockhash, finalTransactionMessage);

const finalSignedTransaction = await signTransactionMessageWithSigners(finalTransactionMessage);
```

---

<ArticleSection name="Send and Confirm Transaction" id="send-confirm" level="h2" />

Send and confirm with the options you configured. Use **confirmed** commitment to match the blockhash; **skipPreflight: true** speeds things up but only when you’re confident in the transaction:

```typescript
import {
  getSignatureFromTransaction,
  isSolanaError,
  SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,
} from "@solana/web3.js";
import { getSystemErrorMessage, isSystemError } from "@solana-program/system";

await sendAndConfirmTransaction(finalSignedTransaction, {
  commitment: "confirmed",
  maxRetries: 0n,
  skipPreflight: true,
});
console.log("Transfer confirmed:", getSignatureFromTransaction(finalSignedTransaction));
```

If you don’t use **skipPreflight**, you can handle **SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE** and **getSystemErrorMessage** for clearer errors.

---

<ArticleSection name="Run the Code" id="run-code" level="h2" />

```bash
npx esrun send-transaction.ts
```

---

<ArticleSection name="Conclusion" id="conclusion" level="h2" />

Solana’s Web3.js 2.0 SDK improves performance, bundle size, and flexibility. Using native crypto, tree-shaking, and autogenerated clients (e.g. Codama), you can build faster and smaller Solana apps in TypeScript/JavaScript.

The full example is available on [GitHub](https://github.com/helius-labs/kite).

---

<ArticleSection name="Resources" id="resources" level="h2" />

- [Now Available: Solana JavaScript SDK 2.0 — Anza Labs](https://www.anza.xyz/blog/solana-javascript-sdk-2)
- [Anza Web3.js 2.0 docs](https://solana-labs.github.io/solana-web3.js/)
- [Breakpoint 2023: Introducing the new Web3.js](https://www.youtube.com/watch?v=breakpoint-web3js) (video)
